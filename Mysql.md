# 数据库原理

> 现在这是我认为一个后端开发人员需要明白的核心.
>
> 这是借鉴的一个简单项目,手写一个数据库,利用java语言.

## 0.Overview

前后端利用socket通信进行交互.

### 核心模块

#### Transaction Manager 事务管理器

​	管理事务的生命周期,实现ACID特性.

​	**交互：** 与 **Version Manager (VM)** 协作来实现隔离性和回滚，并通知 **Data Manager (DM)** 何时需要将变更写入磁盘。

#### Data Manager 数据管理器

​	管理读写,物理存储和持久性.

#### Version Manager 版本管理器

​	实现多版本并发控制,MVCC.

#### Index Manager 索引管理器

​	管理索引,实现B+树或者B树.

#### Table Manager 表管理器

​	比较上层的一个组件,管理table,存储table的元信息.

> 本教程的实现顺序是 TM -> DM -> VM -> IM -> TBM

## 1.实现事务管理器 TM

> ​	你可以理解,我们的事务管理器,只是一直在做一些关于文件的维护,维护当前处理的每一个事务的状态,同时要支持并发的访问.

### XID

xid唯一标识了一个事务.

自增 不重复 

0:超级事务,可以在没有申请事务的情况下进行.--->状态一直是**commited**

> TransactionManager **维护了一个 XID 格式的文件**，用来**记录各个事务的状态**。MYDB 中，每个事务都有下面的三种状态：
>
> 1. **active**，正在进行，尚未结束
> 2. **committed**，已提交
> 3. **aborted**，已撤销（回滚）

> XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处，xid-1 是因为 xid 0（Super XID）的状态不需要记录。

基本的接口:

```java
// 开启事务
    long begin();
    // 提交事务
    void commit(long xid);
    // 取消事务
    void abort(long xid);
    // 查询事务状态
    boolean isActive(long xid);
    boolean isCommitted(long xid);
    boolean isAborted(long xid);
    // 关闭事务管理器
    void close();
```

> 我们这里使用Java的 NIO来进行文件的读写.

### 核心特性：直接内存映射 (Memory-Mapped I/O)

`FileChannel` 最强大的特性之一是它支持 **直接内存映射 I/O (Memory-Mapped I/O, MappedByteBuffer)**。

- **工作原理：** 你可以将文件的一部分甚至整个文件，**映射 (map)** 到 Java 虚拟机的内存中。
- **好处：**
  - 一旦映射完成，对文件内容的读写就像读写内存中的数组一样简单。
  - 操作系统负责在内存和磁盘之间同步数据，**避免了传统 I/O 中数据在内核缓冲区和用户缓冲区之间的多次拷贝**（这是一个巨大的性能提升点）。

对于你的 **Data Manager (DM)** 来说，这非常理想，因为 DM 需要处理大量的随机读写，而内存映射能极大地加速对数据页的访问。

## 2.实现数据管理器 DM

### 实现引用计数缓存框架/共享内存数组(Java没有指针)

> 我们接下来去实现DM.

1.分页管理DB.

2.管理日志文件,发生错误时可以进行恢复.

3.抽象DB文件给上层使用,提供缓存.

> 这就是DAO层的核心,向下会直接管理数据,并且会为上层提供调用的接口.

我们引入**缓存系统**,而我们管理的方式是**引用计数**.

> **为什么不使用LRU算法?**
>
> ​	*某个时刻缓存满了，缓存驱逐了一个资源，这时上层模块想要将某个资源强制刷回数据源，这个资源恰好是刚刚被驱逐的资源。那么上层模块就发现，这个数据在缓存里消失了，这时候就陷入了一种尴尬的境地：是否有必要做回源操作？*
>
> 1. 不回源。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的
> 2. 回源。如果数据项被驱逐时的数据和现在又是相同的，那就是一次无效回源
> 3. 放回缓存里，等下次被驱逐时回源。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致缓存抖动问题

release释放引用,引用为0的时候,就自动驱逐这个资源.

```java
// 尝试获取该资源
            if(maxResource > 0 && count == maxResource) {
                lock.unlock();
                // 缓存已满，抛出异常
                throw Error.CacheFullException;
            }
```

缓存满的时候,直接结束.

这里的所有资源,我们都是使用三张**hash table**来管理的.

### 数据页的缓存和管理问题

我们怎么操作文件系统?

> **读写和缓存**都是以**page**作为**基本单位**.

数据即文件,我们的数据都存放在磁盘文件内部.

> 这里缓存的实现,就是比较基本的缓存思想.

#### 页面管理

db的第一页存放一些元数据,每次打开的时候,和上一次进行校验,看是否合法

剩下的就是正常的数据页.

2bytes 存放当前页面内部的空闲位置的偏移,在做insert的时候,我们主要就是使用这里的数据

### 日志文件和恢复策略

> 这里的恢复思想和文件系统的崩溃恢复是类似的.
>
> MYDB 提供了崩溃后的数据恢复功能。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库奔溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。

```txt
[XChecksum][Log1][Log2][Log3]...[LogN][BadTail]
```

一个基本的日志文件的组成:

1.Checksum对所有log做校验和.

2.BadTail就是崩溃时没有写完的日志数据.

> “Write-Ahead Logging(WAL)”的意思是：**在数据页面的实际修改（写入主数据文件）之前，必须先把描述这个修改的记录（日志）写入并持久化到日志文件。**

#### 恢复策略

Data Manager 为上层提供了两种操作: insert and update with no delete why?

And the same as file system,we use the strategy of WAL.

> 对于两种数据操作，DM 记录的日志如下：
>
> - (Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x
> - (Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx

非并发的情况下,log可能是这样:

```txt
(Ti, x, x), ..., (Ti, x, x), (Tj, x, x), ..., (Tj, x, x), (Tk, x, x), ..., (Tk, x, x)
```

> #### 单线程
>
> 由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下利用日志恢复很简单，假设日志中最后一个事务是 Ti：
>
> 1. 对 Ti 之前所有的事务的日志，进行重做（redo）
> 2. 接着检查 Ti 的状态（XID 文件），如果 Ti 的状态是已完成（包括 committed 和 aborted,这里意味着这里的一个log是完整的.），就将 Ti 重做，否则进行撤销（undo）
>
> 接着，是如何对事务 T 进行 redo：
>
> 1. 正序扫描事务 T 的所有日志
> 2. 如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置
> 3. 如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx
>
> undo 也很好理解：
>
> 1. 倒序扫描事务 T 的所有日志
> 2. 如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除
> 3. 如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx
>
> 注意，MYDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。

考察几种多线程的情况:

```txt
T1 begin
T2 begin
T2 U(x)
T1 R(x)
...
T1 commit
T2 Running
MYDB break down
```

两个事务都在进行的时候,一个事务读取了另外一个事务的更新的内容,但是breakdown的时候,T2应当被撤销.

**级联回滚.**

> I.一个正在进行的事务,不应当读取其余的未提交的事务的数据!

```txt
T1 begin
T2 begin
T1 set x = x+1 // 产生的日志为 (T1, U, A, 0, 1)
T2 set x = x+1 // 产生的日志为 (T1, U, A, 1, 2)
T2 commit
T1 Running
MYDB break down
```

breakdown的时候,T2已经提交事务,但是T1还在进行.

那么我们恢复的时候,对于T2进行重做,对于T1撤销,这个顺序无论怎样,结果都是0或者2.

> II.一个正在进行的事务,不应当修改其余未提交的事务的数据!(但其实是可以的)

实际上VM层可以保证这两点的实现.

> 我们只要保证:
>
> 1. **重做所有崩溃时已完成**（committed 或 aborted）的**事务**
> 2. **撤销所有崩溃时未完成（active）的事务**

### 索引和Data Item的抽象

> 页面索引，缓存了每一页的空闲空间。用于在上层模块进行插入操作时，能够快速找到一个合适空间的页面，而无需从磁盘或者缓存中检查每一个页面的信息。
>
> MYDB 用一个比较粗略的算法实现了页面索引，将一页的空间划分成了 40 个区间。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这 40 个区间中。insert 在请求一个页时，会首先将所需的空间向上取整，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。































